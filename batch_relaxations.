import os, time, gc
import numpy as np, pandas as pd
from multiprocessing import Process, Queue
import cvxpy as cp, mosek

from qcqp_cvxpy_with_sign import QCQP_cvxpy
from lp_to_matrix import load_qcqp_data, dict_to_dense_array

def worker(q, folder, fname, solver, method):
    """Run a single relaxation in isolation."""
    try:
        # 1) Load the raw data
        A_sparse, b_sparse, c_dict, l_dict, u_dict, signs_dict, quad = \
            load_qcqp_data(folder, fname)

        # 2) Convert sparse → dense arrays, just like your original code
        A = np.array([mat.toarray() for mat in A_sparse], dtype=float)
        b = np.array([vec.toarray().flatten() for vec in b_sparse], dtype=float)

        # 3) Fix the objective constant and empty sign for index 0
        c_dict[0] = 0
        signs_dict[0] = ''

        # 4) Convert dicts → 1D arrays
        c     = dict_to_dense_array(c_dict)
        signs = dict_to_dense_array(signs_dict)
        l     = dict_to_dense_array(l_dict)
        u     = dict_to_dense_array(u_dict)

        # 5) Call your solver with the proper shapes
        sol, rt = QCQP_cvxpy(
            A, b, c, l, u, signs,
            solver="mosek",
            relax=method,
            solver_params={mosek.dparam.optimizer_max_time: 8*3600}
        )
        status = "OK"

    except Exception as e:
        sol, rt = None, None
        status = f"ERROR: {e}"

    q.put((method, sol, rt, status))

    
def process_one_file(folder, fname, timeout_map):
    """Spawn a child process per relaxation; enforce per-method timeouts."""
    methods = ["LP_relaxation","SDP_relaxation","SDP'_relaxation"]
    results = {"File Name": fname}
    for m in methods:
        q = Queue()
        p = Process(target=worker, args=(q, folder, fname, "mosek", m))
        p.start()
        p.join(timeout_map[m])
        if p.is_alive():
            p.terminate(); p.join()
            results[f"{m.split('_')[0]} Relaxation Value"] = "TIMEOUT"
            results[f"{m.split('_')[0]} Relaxation Time"]  = timeout_map[m]
        else:
            method, sol, rt, status = q.get()
            results[f"{method.split('_')[0]} Relaxation Value"] = sol if status=="OK" else status
            results[f"{method.split('_')[0]} Relaxation Time"]  = rt
        gc.collect()
    return results


def main():
    folder      = r"C:\Users\suuser\Desktop\buk\MINLPLIB"
    with open("finite_files.txt") as f:
        finite_list = [line.strip() for line in f if line.strip()]
    per_call     = 8*3600 / (len(finite_list)*3)
    timeout_map  = { m: per_call for m in ["LP_relaxation","SDP_relaxation","SDP'_relaxation"] }

    all_results = []
    for fname in finite_list:
        print(f"[{time.strftime('%H:%M:%S')}] Processing {fname}")
        res = process_one_file(folder, fname, timeout_map)
        all_results.append(res)

    df = pd.DataFrame(all_results)
    df.to_excel("MINLPLIB_relaxation_results.xlsx", index=False)
    print("Batch complete!")

if __name__=="__main__":
    main()
    
    
# solver_params={"TimeLimit": 8*3600}
